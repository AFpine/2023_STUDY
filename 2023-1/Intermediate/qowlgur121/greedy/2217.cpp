/*
이 문제에서 원하는 건 들 수 있는 “최대” 중량이다. “최대, 최소”같은 것을 원하면 그리디로 접근하자.

그리디는 각 단계에서 **최선의 선택**을 하는 것이다.

**먼저 무게가 가장 큰 로프로부터 사용하는 것**이 최선의 선택이다.

그 다음으로 큰 로프를 사용하는 것이 그 다음 단계에서의 최선이다.

의사코드. 

1. n을 입력 받는다.
2. n개의 로프 중량을 입력 받는다.
3. 입력 받은 로프 중량을 오름차순으로 정렬한다.
4. 1부터 n까지 반복하는데 ans를 이용해서 n-i개의 로프 중 가장 큰 중량과 i를 곱한 값 중 큰 값으로 갱신한다.

*/

#include <iostream>
#include <algorithm>

int n;
int w[100005];

int main() {
	std::ios::sync_with_stdio(0);
	std::cin.tie(0);
	std::cin >> n;
	for (int i = 0; i < n; i++) std::cin >> w[i];
	std::sort(w, w + n);
	int ans = 0;
	for (int i = 1; i <= n; i++)
		ans = std::max(ans, w[n - i] * i); //w[n - i] * i은 가장 중량이 큰 i개의 로프를 사용했을 때 들어올릴 수 있는 최대 중량
	std::cout << ans;
}

/*
예시로 [10, 15, 20, 25]가 됨.
그리고 for문에서 i가 1일 때 ans는 25가 된다.
이는 가장 큰 중량을 들 수 있는 로프인 25를 사용했을 때 들어올릴 수 있는 최대 중량임. 
i가 2일 때 ans는 40이 됨. 
이는 25와 20을 사용했을 때 들어올릴 수 있는 최대 중량이다. 
i가 3일 때 ans는 45가 됨. 
이는 25, 20, 15를 사용했을 때 들어올릴 수 있는 최대 중량이다. 
마지막으로 i가 4일 때 ans는 40이 된다. 
이는 모든 로프를 사용해서 들어올릴 수 있는 최대 중량임.
*/
