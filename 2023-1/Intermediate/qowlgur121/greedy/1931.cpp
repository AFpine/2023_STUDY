/*

이 문제에서 원하는 게 “최대 사용할 수 있는 회의의 최대 개수”이다. 이처럼 “최대”이런 걸 요구하면 그리디를 고려하자.

그리디를 적용하려면 가능한 많은 회의를 선택해야 한다는 것이 핵심. 

가장 빨리 끝나는 회의를 선택하고, 그 이후로 가능한 빨리 시작하는 회의를 선택하면서 회의를 최대한 많이 선택하는 방법을 선택하면 된다.

과정.

1. 모든 회의를 끝나는 시간을 기준으로 오름차순으로 정렬한다.
2. 가장 빨리 끝나는 회의를 선택한다.
3. 선택된 회의 이후에 시작하는 회의 중에서 가장 빨리 끝나는 회의를 선택한다.
4. 3번의 과정을 반복하면서 선택된 회의의 수를 증가시킨다.
5. 선택된 회의의 수를 출력한다.

다시 말하지만 그리디 알고리즘은 매 단계에서 가장 최선의 선택을 하는 알고리즘이다.

그리디.

**종료 시간 이후 시작하는 것 중 가장 빨리 끝나는 것을 선택**하면 된다.

**즉, 종료 시간을 기준으로 정렬한 다음, 시작 시간이 전 회의가 종료 시간보다 같거나 크면 선택**하면 됩니다.



*/

#include <iostream>
#include <algorithm>

int n;
std::pair<int, int> s[100005];

int main() {
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);
    std::cin >> n;
    for (int i = 0; i < n; i++)
        std::cin >> s[i].second >> s[i].first;
    std::sort(s, s + n);
    int t = 0;
    int ans = 0;
    for (int i = 0; i < n; i++) {
        if (t > s[i].second) continue;   //정렬때문에 입력을 반대로 받아서 사실 이게 종료시간
        ans++;
        t = s[i].first;        //이게 시작시간
    }
    std::cout << ans;
}
